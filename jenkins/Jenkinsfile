pipeline {
    agent any
    
    environment {
        PYTHON_VERSION = '3'
        VENV_DIR = 'venv'
        RESPONSE_EMAIL = 'denis1988@gmail.com'
    }
    
    stages {
        stage('Setup Environment') {
            when {
                expression { return true }
            }
            steps {
                script {
                    sh 'echo "Setting up Python environment"'
                    sh "python${PYTHON_VERSION} -m venv ${VENV_DIR}"
                    sh ". ${VENV_DIR}/bin/activate && pip install --upgrade pip"
                    sh ". ${VENV_DIR}/bin/activate && pip install -r requirements.txt"
                }
            }
        }
        
        stage('Lint Code') {
            when {
                expression { return true }
            }
            steps {
                script {
                    sh ". ${VENV_DIR}/bin/activate && flake8 app/ --output-file=reports/flake8.txt || true"
                    sh ". ${VENV_DIR}/bin/activate && pylint app/ --output=reports/pylint.txt || true"
                }
            }
            post {
                always {
                    archiveArtifacts artifacts: 'reports/*.txt', allowEmptyArchive: true
                }
            }
        }
        
        stage('Unit Tests') {
            when {
                expression { return true }
            }
            steps {
                script {
                    sh 'docker rm -f unit-test-app || true'
                    sh 'docker build -f docker/Dockerfile.app -t my-temp-app .'
                    sh 'docker run -d -p 5000:5000 --name unit-test-app my-temp-app'
                    sh 'mkdir -p reports'
                    sh ". ${VENV_DIR}/bin/activate && pytest tests/unit/ -v --cov=app --cov-report=xml --cov-report=html --junit-xml=reports/unit-tests.xml"
                }
            }
            post {
                always {
                    sh 'docker rm -f unit-test-app || true'
                    junit 'reports/unit-tests.xml'
                    publishHTML([
                        allowMissing: false,
                        alwaysLinkToLastBuild: true,
                        keepAll: true,
                        reportDir: 'htmlcov',
                        reportFiles: 'index.html',
                        reportName: 'Unit Test Coverage Report'
                    ])
                    archiveArtifacts artifacts: 'htmlcov/**/*', allowEmptyArchive: false
                }
            }
        }
        
        stage('Integration Tests') {
            when {
                expression { return true }
            }
            steps {
                script {
                    sh 'docker rm -f integration-test-app || true'
                    sh 'docker build -f docker/Dockerfile.app -t my-temp-app .'
                    sh 'docker run -d -p 5000:5000 --name integration-test-app my-temp-app'
                    sh 'mkdir -p reports'
                    sh ". ${VENV_DIR}/bin/activate && pytest tests/integration/ -v --junit-xml=reports/integration-tests.xml"
                }
            }
            post {
                always {
                    sh 'docker rm -f integration-test-app || true'
                    junit 'reports/integration-tests.xml'
                }
            }
        }
        
        stage('End-to-End Tests') {
            when {
                expression { return true }
            }
        steps {
            script {
            sh 'docker rm -f e2e-test-app || true'
            sh 'docker build -f docker/Dockerfile.app_selenium -t my-temp-app-selenium .'
            sh 'docker run -d --name e2e-test-app my-temp-app-selenium tail -f /dev/null'

            sh '''
                docker exec \
                -e HEADLESS=true \
                -e CI=true \
                -e PYTHONUNBUFFERED=1 \
                -e DISPLAY= \
                e2e-test-app \
                pytest tests/e2e/ -v \
                    --cov=app --cov-report=xml \
                    --junit-xml=reports/e2e-tests.xml
            '''

            sh 'mkdir -p reports'
            sh 'docker cp e2e-test-app:/opt/DevOps-CI-CD-exercise/reports/e2e-tests.xml reports/e2e-tests.xml'
            }
        }
        post {
            always {
            sh 'docker rm -f e2e-test-app || true'
            junit 'reports/e2e-tests.xml'
            }
        }
        }

        
        stage('Performance Tests') {
            when {
                expression { return true }
            }
            steps {
                script {
                    sh 'docker rm -f performance-test-app || true'
                    sh 'docker build -f docker/Dockerfile.app_prod -t performance-test-app .'
                    sh 'docker run -d -p 5000:5000 --name performance-test-app performance-test-app'
                    sh 'mkdir -p reports'
                    sh "docker exec performance-test-app locust -f tests/performance/locustfile.py --headless --users 10 --spawn-rate 2 --run-time 30s --host http://localhost:5000 --html reports/performance-report.html"
                    //sh 'docker cp performance-test-app:/opt/DevOps-CI-CD-exercise/reports/performance-report.html reports/performance-report.html || true'
                    //sh 'locust -f locustfile.py --headless --users 10 --spawn-rate 2 --run-time 30s --host http://localhost:5000 --html reports/performance-report.html'
                }
            }
            post {
                always {
                    sh 'docker rm -f performance-test-app || true'
                    publishHTML([
                        allowMissing: false,
                        alwaysLinkToLastBuild: true,
                        keepAll: true,
                        reportDir: 'reports',
                        reportFiles: 'performance-report.html',
                        reportName: 'Performance Test Report'
                    ])
                }
            }
        }

            stage('Build and Push Images') {
                when {
                expression { return false }
            }
            steps {
                script {
                    def dockerHubUser = "denis20"
                    def githubUser    = "denis1988"
                    // Standardize the name to avoid mismatches
                    def repoName      = "devops-ci-cd-exercise" 

                    // Build the local image
                    sh "docker build -f docker/Dockerfile.app_prod -t ${repoName}:${env.BUILD_NUMBER} ."

                    // Docker Hub
                    withCredentials([usernamePassword(credentialsId: 'dockerhub-creds', 
                                                    passwordVariable: 'DOCKER_HUB_PASSWORD', 
                                                    usernameVariable: 'DOCKER_HUB_USER')]) {
                        sh """
                            echo \$DOCKER_HUB_PASSWORD | docker login -u \$DOCKER_HUB_USER --password-stdin
                            docker tag ${repoName}:${env.BUILD_NUMBER} ${dockerHubUser}/${repoName}:${env.BUILD_NUMBER}
                            docker tag ${repoName}:${env.BUILD_NUMBER} ${dockerHubUser}/${repoName}:latest
                            docker push ${dockerHubUser}/${repoName}:${env.BUILD_NUMBER}
                            docker push ${dockerHubUser}/${repoName}:latest
                        """
                    }

                    // GitHub Container Registry (ensure repoName is lowercase for GHCR)
                    withCredentials([usernamePassword(credentialsId: 'github-creds', 
                                                    passwordVariable: 'GH_PAT', 
                                                    usernameVariable: 'GH_USER')]) {
                        sh """
                            echo \$GH_PAT | docker login ghcr.io -u \$GH_USER --password-stdin
                            docker tag ${repoName}:${env.BUILD_NUMBER} ghcr.io/${githubUser}/${repoName}:${env.BUILD_NUMBER}
                            docker tag ${repoName}:${env.BUILD_NUMBER} ghcr.io/${githubUser}/${repoName}:latest
                            docker push ghcr.io/${githubUser}/${repoName}:${env.BUILD_NUMBER}
                            docker push ghcr.io/${githubUser}/${repoName}:latest
                        """
                    }
                }
            }

        stage('Deploy to Staging') {
                    steps {
                        script {
                            // Replace 'YOUR_EC2_PUBLIC_IP' with your actual instance IP
                            def ec2Ip = "34.216.141.130"
                            def dockerHubUser = "denis20"
                            def repoName = "devops-ci-cd-exercise"

                            // Use the SSH agent to manage your .pem key
                            sshagent(['aws-ec2-ssh']) {
                                sh """
                                    ssh -o StrictHostKeyChecking=no ubuntu@${ec2Ip} << 'EOF'
                                        # Log in to Docker Hub on the EC2 instance
                                        # (Assumes you have manually logged in once or set up a config)
                                        
                                        # Pull the latest image
                                        docker pull ${dockerHubUser}/${repoName}:latest
                                        
                                        # Stop and remove existing container
                                        docker stop staging-app || true
                                        docker rm staging-app || true
                                        
                                        # Run the new container
                                        docker run -d --name staging-app -p 5000:5000 ${dockerHubUser}/${repoName}:latest
                                        
                                        # Optional: Wait for startup and check health locally on EC2
                                        sleep 5
                                        curl -f http://localhost:5000/health || exit 1
                                        EOF
                                """
                            }
                        }
                    }
    post {
        always {
            cleanWs()
        }
        success {
            script {
                sh 'echo "Pipeline completed successfully!"'
                emailext (
                    subject: "✅ Pipeline Success: ${env.JOB_NAME} - ${env.BUILD_NUMBER}",
                    mimeType: 'text/html',
                    body: """
                        <p>The pipeline completed successfully!</p>
                        <ul>
                            <li><strong>Build:</strong> ${env.BUILD_NUMBER}</li>
                            <li><strong>Branch:</strong> ${env.BRANCH_NAME}</li>
                            <li><strong>Duration:</strong> ${currentBuild.durationString}</li>
                        </ul>
                        <p><a href="${env.BUILD_URL}">View Build Details</a></p>
                    """,
                    to: "${RESPONSE_EMAIL}"
                )
            }
        }
        failure {
            script {
                sh 'echo "Pipeline failed!"'
                emailext (
                    subject: "❌ Pipeline Failure: ${env.JOB_NAME} - ${env.BUILD_NUMBER}",
                    mimeType: 'text/html',
                    body: """
                        <p>The pipeline failed!</p>
                        <ul>
                            <li><strong>Build:</strong> ${env.BUILD_NUMBER}</li>
                            <li><strong>Branch:</strong> ${env.BRANCH_NAME}</li>
                            <li><strong>Duration:</strong> ${currentBuild.durationString}</li>
                            <li><strong>Failed Stage:</strong> ${currentBuild.currentResult}</li>
                        </ul>
                        <p><a href="${env.BUILD_URL}">View Build Details</a></p>
                    """,
                    to: "${RESPONSE_EMAIL}"
                )
            }
        }
    }
    }
}